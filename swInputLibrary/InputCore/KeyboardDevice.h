#pragma once
/**
@file KeyboardDevice.h
@author nieznanysprawiciel
@copyright File is part of Sleeping Wombat Libraries.
*/

#include "Device.h"

#include "KeyboardState.h"
#include "InputDeviceInfo.h"
#include "InputDeviceEvent.h"

#include "EventQueue.h"

#include <queue>


namespace sw {
namespace input
{


/**@brief Keyboard state and events.

There are 2 types of events for keyboard.
- KeyEvent which means state of physicall key.
- CharacterEvent which tells about character generated by device.

Although character events depend on physical input, there's no one to one relationship between them.
Operating system processes characters in different manner. For example when you hold keyboard button with letter,
it will be repeated multiple times, despite of the fact that it was clicked only once. Another examples are keys
that give special meaning to buttons like shift or alt.

When you apply events to current @ref KeyboardState only KeyEvents are processed and CharacterEvents are ignored.
m_characters vector is usefull in case of GUI systems and text fields, where you don't want to translate keyboard state
to letters by yourself.

@ingroup Input*/
class KeyboardDevice : public Device
{
private:

	InputDeviceInfo		m_info;
	KeyboardState		m_state;

	EventQueue< DeviceEvent >		m_events;

protected:
public:
	explicit		KeyboardDevice		() = default;
					~KeyboardDevice		() = default;


	const InputDeviceInfo&		GetInfo			() const	{ return m_info; }
	const KeyboardState&		GetState		() const	{ return m_state; }

	EventQueue< DeviceEvent >&			GetEventsQueue		()			{ return m_events; }

	void						ApplyAllEvents				();
	DeviceEvent					ApplyNextEvent				();
	Timestamp					GetNextEvtTimestamp			();

	void						RemoveEvents				();

public:

	///@name Functions for setting state (only for IInput)
	///@{

	/**@brief Add event to event queue.
	This function doesn't change KeyboardState.*/
	void			AddEvent		( const DeviceEvent& event );

	///@}

};

DEFINE_OPTR_TYPE( KeyboardDevice );

//====================================================================================//
//			Inline implementation	
//====================================================================================//


// ================================ //
//
inline void			KeyboardDevice::ApplyAllEvents	()
{
	while( !m_events.NoMoreEvents() )
	{
		auto& event = m_events.PopEvent();
		
		// Characters don't influence KeyboardState.
		if( event.Type == DeviceEventType::KeyboardEvent )
			m_state.ApplyEvent( event );
	}
}

// ================================ //
//
inline DeviceEvent	KeyboardDevice::ApplyNextEvent()
{
	if( m_events.NoMoreEvents() )
		return DeviceEvent();


	auto& nextEvent = m_events.PopEvent();
	m_state.ApplyEvent( nextEvent );

	return nextEvent;
}

// ================================ //
//
inline Timestamp	KeyboardDevice::GetNextEvtTimestamp()
{
	return m_events.FrontEvent().LogicalTime;
}

// ================================ //
//
inline void			KeyboardDevice::RemoveEvents		()
{
	m_state.RemoveEvents();
	m_events.ClearReadEvents();
}


// ================================ //
//
inline void			KeyboardDevice::AddEvent		( const DeviceEvent& event )
{
	m_events.AddEvent( event );
}


}	// input
}	// sw

