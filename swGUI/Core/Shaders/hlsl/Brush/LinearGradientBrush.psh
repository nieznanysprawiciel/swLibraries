
#define MAX_GRADIENTS_STOPS 127


// ================================ //
//
struct GradientStop
{
	uint		Color;
	float		Offset;
};

// ================================ //
//
cbuffer LinearGradientBrushConsts : register( b0 )
{
	float2				StartPoint;
	float2				StopPoint;
	uint				NumStops;
	GradientStop		GradientStops[ MAX_GRADIENTS_STOPS ];
}


// ================================ //
//
float4		LoadIntColor		( uint color )
{
	// Color format 0xAARRGGBB

	float4 result;
	result.w = ( color & 0xFF000000 ) >> 24;
	result.x = ( color & 0x00FF0000 ) >> 16;
	result.y = ( color & 0x0000FF00 ) >> 8;
	result.z = color & 0x000000FF;

	return result / 255.0;
}

// ================================ //
//
float4		ComputeColor		( float factor, GradientStop first, GradientStop second )
{
	float4 firstColor = LoadIntColor( first.Color );
	float4 secondColor = LoadIntColor( second.Color );

	return lerp( firstColor, secondColor, factor );
}


// ================================ //
//
float4		BrushFunction		( float4 pos, float2 tex )
{
	float2 gradientVec = StopPoint - StartPoint;
	float2 pixelVec = tex - StartPoint;

	float factor = dot( gradientVec, pixelVec ) / dot( gradientVec, gradientVec );

	// Handle situation, when we are before first GradientStop.
	if( factor < GradientStops[ 0 ].Offset )
		return LoadIntColor( GradientStops[ 0 ].Color );

	// Find pair of GradientStops. Our pixel shoudl be between them.
	uint i = 1;
	for( ; i < NumStops; ++i )
	{
		if( factor < GradientStops[ i ].Offset )
		{
			return ComputeColor( factor, GradientStops[ i - 1 ], GradientStops[ i ] );
		}
	}

	// Handle situation, when we are after last GradientStop.
	return LoadIntColor( GradientStops[ NumStops - 1 ].Color );
}

